Given a number of at most 100 digits. We have to check if it is possible, after removing certain digits, to obtain a number of at least one digit which is divisible by 8. We are forbidden to rearrange the digits.

Examples:

Input : 1787075866
Output : Yes
There exist more one or more subsequences
divisible by 8. Example subsequences are
176, 16 and 8.

// CPP program to check if a subsequence of digits
// is divisible by 8.
#include <bits/stdc++.h>
using namespace std;
 
// Function to calculate any permutation divisible
// by 8. If such permutation exists, the function
// will return that permutation else it will return -1
bool isSubSeqDivisible(string str)
{
    //write your implementation here
}
 
// Driver function
int main()
{
    string str = "3144";
    if (isSubSeqDivisible(str))
       cout << "Yes";
    else
       cout << "No";
    return 0;
}

ANSWER1

// Generating all possible permutations and checking
    // if any such permutation is divisible by 8
    for (int i = 0; i < l; i++) {
        for (int j = i; j < l; j++) {
            for (int k = j; k < l; k++) {
                if (arr[i] % 8 == 0)
                    return true;
 
                else if ((arr[i]*10 + arr[j])%8 == 0 &&
                         i != j)
                    return true;
 
                else if ((arr[i] * 100 + arr[j] * 10 + 
                          arr[k]) % 8 == 0 && i != j && 
                          j != k && i != k)
                    return true;
            }
        }
    }
    return false;

2. Given N boxes and their size in an array. You are allowed to keep a box inside another box only if the box in which it is held is empty and the size of the box is at least twice as large as the size of the box. The task is to find minimum number of visible boxes.

Examples –

Input : arr[] = { 1, 3, 4, 5 }
Output : 3
Put box of size 1 in box of size 3.

// CPP program to count number of visible boxes.
#include <bits/stdc++.h>
using namespace std;
 
// return the minimum number of visible boxes
int minimumBox(int arr[], int n)
{
    queue<int> q;
 
    // sorting the array
    sort(arr, arr + n);
 
    q.push(arr[0]);
 
    // traversing the array
    for (int i = 1; i < n; i++)  {
 
        int now = q.front();
 
        // checking if current element
        // is greater than or equal to
        // twice of front element
        if (arr[i] >= 2 * now)
            q.pop();
 
        // Pushing each element of array
        q.push(arr[i]);
    }
 
    return q.size();
}
 
// driver Program
int main()
{
    int arr[] = { 4, 1, 2, 8 };
    int n = sizeof(arr) / sizeof(arr[0]);
    cout << minimumBox(arr, n) << endl;
    return 0;
}

